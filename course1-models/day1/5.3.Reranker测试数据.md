
### 🎯 Reranker 测试集怎么做出来的？（面向 cross-encoder）

Reranker 只负责 排序 top-k 的候选文档，不负责召回。
因此测试集必须包含：
- 一个 query
- 多个候选 doc
- 每个 doc 的正确性标签（1 正确 / 0 不正确）



#### 步骤 1：准备 queries（同 embedding）

→ 可共用 embedding 测试集中的 query

#### 步骤 2：为每个 query 构造候选文档集合（candidates）

候选集合来源：

##### 方法 ①：embedding 检索 top-50（真实办法）

真实系统中：
- 用 embedding 检索出 top-50
- 从中人工标注正负样本

这是最真实的测试集做法。

##### 方法 ②：知识库中人工挑选候选文档

适用于知识库规模小的情况。

##### 方法 ③：自动生成 hard negative 再人工确认

例如：
```
query：怎么补开发票？

candidates：
正确答案文档（positive）
发票相关但不正确的文档（hard negative）
无关文档（negative）
```
#### 步骤 3：给候选文档打标签（label）

标签格式：
```
1 = 正确回答
0 = 错误回答 / 不相关回答
```
示例：
```py
{
  "query": "怎么补开发票？",
  "candidates": [
    {
      "doc": "发票补开流程：进入订单详情→发票管理→申请补开。",
      "label": 1
    },
    {
      "doc": "退货流程说明：……",
      "label": 0
    },
    {
      "doc": "发票抬头修改方法：……",
      "label": 0
    }
  ]
}
```

##### 📌 Reranker 测试集需要包含 Hard Negatives

为什么要包含？
因为 reranker 的价值就在于纠正 embedding 抓不到的细节。

例如：
```
query：怎么申请退货？

候选1：退货申请流程（positive）
候选2：退款多久到账（hard negative） ← embedding 有时会误认为相关
候选3：积分如何使用？（negative）
```

一个强 reranker 应该：
- 把候选1排第一
- 把候选2排在后面
- 把候选3排最后

