## MCP 的通信方式（Transport）

- 开发 / 本机玩玩：`stdio` 最简单，把 server 当子进程起就行。
- 要部署成远程服务、给多个客户端共用：用 `HTTP / WebSocket / SSE` 更合适（比如部署在 `服务器、K8s、Docker` 等）


`MCP` 与工具之间不是直接通过 `HTTP API`，而是支持 `多种传输层（Transport）`，主要有三类：

### 1. stdio（最常用、本地场景）

- 工具进程通过 标准输入/输出（stdin/stdout） 与客户端通信
- 常用于本地开发、命令行、编辑器插件（VS Code、Cursor）

>流程示例
```
Client 通过 subprocess 启动 Tool Server
         ↓
Tool Server 读取 stdin → JSON-RPC 请求
         ↑
Client 从 stdout 获取 JSON-RPC 响应
```

>优点
- 简单，不需要网络
- 工具服务可以“跟随进程启动”

### 2. WebSocket（远程工具最常用）

采用：

>JSON-RPC over WebSocket

工具服务可以部署在服务器，让多个客户端共享。

例子：
你写了一个 get_weather MCP 工具，部署在 ws://tools.mycompany.com/weather，
你的 Qwen/Claude Agent、浏览器插件、桌面应用都可以连它。

优点：
- 跨机器 / 远程可访问
- 全双工，实时推送
- 通用服务器部署方式（配合 uvicorn/fastapi）

#### 3. SSE / HTTP（浏览器 & 轻量客户端）

- 浏览器扩展常用 SSE（事件流）
- 客户端发送请求 → 工具推送事件 → 返回 JSON-RPC 数据
- 易于被 Web 前端接入

适用场景：
- Browser Extension
- Web App
- 限制无法使用 WebSocket 的环境

### 4. MCP 通信内容：JSON-RPC

无论是 WebSocket 还是 stdio/SSE，最核心都是：

>所有消息 = JSON-RPC 2.0 格式

例如工具调用请求：
```py
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "callTool",
  "params": {
    "name": "get_weather",
    "arguments": { "city": "深圳" }
  }
}
```

工具返回：
```py
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      { "type": "text", "text": "{...weather result...}" }
    ]
  }
}
```

模型端（如 Qwen）看到：

- 工具名：get_weather
- 调用参数 schema：来自 MCP list_tools() 的描述
- 工具结果：模型当成普通文字继续推理