
### 2 async / await / async with 是干啥的？
#### 1. async def —— 声明「这个函数是协程」

没有 async：
```py
def foo():
    return 1
x = foo()  # x 就是 1，函数已经执行完了
```

有 async：
```py
async def foo():
    return 1
x = foo()  # x 不是 1，而是一个 coroutine 对象
```

要用：
```py
result = await foo()
```

在你的代码里：
```py
async def chat_loop()

async def run_agent_once(...)

async def get_oai_tools_from_mcp(...)

async def call_mcp_tool(...)

async def mcp_asgi_app(scope, receive, send)
```
这些都是 协程函数，表明它们里面用到了 await，要在事件循环里调度执行。

#### 2. await —— 暂停当前协程，把控制权交还给事件循环

`await` 后面必须跟：
- 协程（coroutine）
- 或者 `asyncio.Future / Task` 之类的 `awaitable`

作用：
>“我现在在干一个 I/O 或异步操作，先挂起，等它完成再叫醒我；这段时间你（事件循环）可以去干别的事。”

比如你的 client：
```py
async with websocket_client(ws_url) as (read_stream, write_stream):
    async with mcp.ClientSession(read_stream, write_stream) as mcp_session:
        await mcp_session.initialize()
        oai_tools = await get_oai_tools_from_mcp(mcp_session)
        ...
```

- `await mcp_session.initialize()`：等待和 MCP server 完成握手、能力协商；
- `await get_oai_tools_from_mcp(...)`：让出控制权等待 list_tools 的网络请求回来。

#### 3. async with —— 异步上下文管理器

普通的上下文管理器你肯定熟：
```py
with open("a.txt") as f:
    data = f.read()
```

底层是调用 `__enter__` 和 `__exit__` 两个方法。

异步上下文管理器：
```py
async with websocket_client(ws_url) as (read_stream, write_stream):
    ...
```

底层是：
- `__aenter__`（返回 awaitable）
- `__aexit__`（返回 awaitable）

等价于：
```py
cm = websocket_client(ws_url)
read_stream, write_stream = await cm.__aenter__()
try:
    ...
finally:
    await cm.__aexit__(...)
```

也就是说：

- 建立 WebSocket 连接是 await 的异步操作
- 退出 context（关闭连接、清理任务）也是 await 的异步操作

在你的 server 端：
```py
async with websocket_server(scope, receive, send) as (read_stream, write_stream):
    await mcp_server._mcp_server.run(...)
```

也是一样的结构：

- 进入时：完成握手、创建读写流；
- 退出时：关闭 WebSocket、清理资源。

#### 4. asyncio.run —— 顶层“开车”的那个人

因为不能在模块顶层直接 await，所以需要一个同步的入口来帮你：
```py
def main():
    asyncio.run(chat_loop())

if __name__ == "__main__":
    main()
```

`asyncio.run(coro)` 内部 roughly 等价于：
```py
loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)
try:
    loop.run_until_complete(coro)
finally:
    loop.close()
```

也就是：
>“我帮你创建一个 event loop，把这个协程跑完，然后关掉 loop。”