## 总结

### 1 整个调用链

以你现在跑的这套为例：

#### 1.1 进程层面

- 进程 A：python server_ws_fastapi.py
- 进程 B：python client_ws.py

两者之间通过 WebSocket（TCP）通信。

#### 1.2 服务器进程 A 内部

##### 1 Uvicorn 启动事件循环 loop
##### 2 有人连 `ws://127.0.0.1:8000/mcp/` 时：
1. 请求被路由到 `mcp_asgi_app`
2. 进入这段：
    ```py
    async with websocket_server(scope, receive, send) as (read_stream, write_stream):
        await mcp_server._mcp_server.run(...)
    ```
3. `websocket_server(...)` 在内部完成：
    - WebSocket 握手（`accept(subprotocol="mcp")`）
    - 创建 reader/writer 协程

4. `mcp_server._mcp_server.run(...)` 开始在这个连接上处理 `JSON-RPC` 请求：
    - 收到 `list_tools` → 调 `@mcp_server.tool()` 注册的工具列表 → 返回
    - 收到 `callTool(get_weather, ...)` → 在当前线程/线程池中执行 `get_weather(...)` → 把结果塞到 JSON-RPC 的响应里发回去

所有这些 async 操作都是在 一个线程 + 一个 event loop 里调度的。

#### 1.3 客户端进程 B 内部

##### 1. `asyncio.run(chat_loop())` 创建 event loop 并跑协程

##### 2. 在 `chat_loop()` 中：
```py
async with websocket_client(ws_url) as (read_stream, write_stream):
    async with mcp.ClientSession(read_stream, write_stream) as mcp_session:
        await mcp_session.initialize()
        oai_tools = await get_oai_tools_from_mcp(mcp_session)
        ...
```
- websocket_client：在事件循环里建立 WebSocket 连接，起两个协程：
    - 一个专门读 WebSocket 消息；
    - 一个专门写 JSON-RPC 消息。
- `ClientSession.initialize()`：发送 MCP 的 initialize 请求，等待 server 返回能力信息；
- `get_oai_tools_from_mcp` 调 `list_tools()`，得到 `get_weather / search_info_by_tavily`。

##### 3. 之后进入你的 agent 主循环：

- LLM 决定要不要调用工具（function calling）；
- 需要的话，await call_mcp_tool(...) 发送 callTool 给 MCP server；
- 等待 server 通过 WebSocket 回 JSON-RPC 响应；
- 再把工具结果放回历史，把控制权交给 LLM 做总结。

### 2 一句话总结

- 进程：一个 Python 程序实例（server 一份 / client 一份）
- 线程：进程里的执行单元，Uvicorn 大多数时候只用一个主线程 + 线程池（跑阻塞任务）
- 协程：在单线程里跑很多 I/O 任务的小单元，靠 async / await + 事件循环调度
- `async def`：声明“我是一个协程函数”
- `await`：在协程里挂起自己，等异步任务完成
- `async with`：异步版 with，配合网络连接、会话之类资源
- `asyncio.run`：脚本级入口，帮你创建 event loop 并跑一个顶层协程
- `@mcp_server.tool`：把一个函数注册成 MCP 工具，和 async/await 是两条线