## 进程、线程、协程

### 1. 进程（process）

你跑：
```
python server_ws_fastapi.py
python client_ws.py
```

这就是启动了 两个独立的进程。

进程之间完全隔离：内存不共享，通过 网络（WebSocket） 来通信。

每个进程有自己的 Python 解释器、自己的 GIL、自己的内存空间。

所以：
- `server_ws_fastapi.py` = 服务器进程
- `client_ws.py` = 客户端进程

它们之间全靠 `ws://127.0.0.1:8000/mcp/` 来对话

### 2. 线程（thread）

在每个进程里面，可以有很多线程。

`Uvicorn / FastAPI` 默认是用 `单进程 + 单线程 + asyncio 事件循环` 来做并发 I/O；
但它内部也可能有一个 `线程池` 去跑同步阻塞任务（比如调用 requests）。

在你的服务端：
```py
uvicorn.run(app, host="127.0.0.1", port=8000)
```
- Uvicorn 在这个进程里创建一个事件循环（event loop）
- 所有 async 的 HTTP / WebSocket 处理都是在同一个线程里通过 协程 来并发执行
- 如果你在 async 代码里调用了同步阻塞函数（比如 requests.get），FastAPI / Starlette 有时会帮你丢到一个线程池去执行，避免把整个事件循环堵死

#### 3. 协程（coroutine）

协程是 Python 在 asyncio 模型下最核心的并发单位：

- 用 `async def` 定义出来的函数，调用之后不会立刻执行完，而是返回一个 协程对象（coroutine）
- 只有在 `await` 它的时候，才会真正把控制权交给事件循环去调度执行

例子（你代码里的）：
```py
async def chat_loop():
    ...
```

这是一个 协程函数，调用 chat_loop() 得到的是协程对象，要用：
```py
asyncio.run(chat_loop())
```

才能真正跑起来