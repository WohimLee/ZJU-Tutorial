## 进程、线程、协程

### 1. 进程（process）

你跑：
```
python server_ws_fastapi.py
python client_ws.py
```

这就是启动了 两个独立的进程。

进程之间完全隔离：内存不共享，通过 网络（WebSocket） 来通信。

每个进程有自己的 Python 解释器、自己的 GIL、自己的内存空间。

所以：
- `server_ws_fastapi.py` = 服务器进程
- `client_ws.py` = 客户端进程

它们之间全靠 `ws://127.0.0.1:8000/mcp/` 来对话

### 2. 线程（thread）

在每个进程里面，可以有很多线程。

`Uvicorn / FastAPI` 默认是用 `单进程 + 单线程 + asyncio 事件循环` 来做并发 I/O；
但它内部也可能有一个 `线程池` 去跑同步阻塞任务（比如调用 requests）。

在你的服务端：
```py
uvicorn.run(app, host="127.0.0.1", port=8000)
```
- Uvicorn 在这个进程里创建一个事件循环（event loop）
- 所有 `async` 的 `HTTP / WebSocket` 处理都是在同一个线程里通过 协程 来并发执行
- 如果你在 `async` 代码里调用了同步阻塞函数（比如 requests.get），`FastAPI / Starlette` 有时会帮你丢到一个线程池去执行，避免把整个事件循环堵死

#### 3. 协程（coroutine）

协程（coroutine）通常是进程内、线程内的概念，它是用户态的轻量级“协作式”调度单元，不依赖内核线程调度。

协程的核心思想是：让开发者在用户态控制执行点的挂起与恢复，从而 **避免线程切换的内核开销**

因此：
- 协程不能跨进程调度（因为完全依赖用户态逻辑和进程内存）
- 协程通常运行在某个线程内（多线程下可有多组协程）

换句话说：协程是比线程更轻量的调度单位，但它本质仍 **依附于线程**──线程再归属于进程。

协程是 Python 在 asyncio 模型下最核心的并发单位：

- 用 `async def` 定义出来的函数，调用之后不会立刻执行完，而是返回一个 协程对象（coroutine）
- 只有在 `await` 它的时候，才会真正把控制权交给事件循环去调度执行

例子（你代码里的）：
```py
async def chat_loop():
    ...
```

这是一个 协程函数，调用 `chat_loop()` 得到的是协程对象

要用：
```py
asyncio.run(chat_loop())
```

才能真正跑起来