## asyncio：Python 官方的协程调度器
### asyncio 是什么
`asyncio` 可以理解为：

>在单线程里“假装”同时做很多 I/O 的调度器

主角是 `事件循环（event loop）`：

- 把所有协程任务（network I/O、sleep 等）挂在一个循环里
- 每个任务在 I/O 等待的时候主动让出控制权，事件循环就去跑别的任务
- 所以在一个线程里可以“并发”处理很多连接


##### ✨ 事件循环 Event Loop 的工作方式（非常简化）

事件循环基本上是这样的伪代码：
```py
while True:
    ready = 收集所有“可以继续运行的协程”
    for task in ready:
        执行 task 的一小段（直到下一个 await）
    等待某些 I/O 事件发生（使用 epoll/select/kqueue）
```

也就是说：
- 协程不会一次性执行完
- 每次运行一小段，执行到 await 就暂停（挂起）
- 当某个事件（如 socket 可读）发生，event loop 再继续执行挂起的协程

##### 和你的代码的关系
>客户端顶层入口：
```
def main():
    asyncio.run(chat_loop())
```
- `asyncio.run()` 会：
    - 在当前进程、当前线程里创建事件循环
    - 把协程 `chat_loop()` 丢进去跑直到完成
    - 关闭事件循环，收尾

>服务端（Uvicorn）

`uvicorn.run(app, ...)` 内部也是搞了个类似的事情：

- 创建事件循环
- 把 `FastAPI/Starlette` 的 `ASGI` 应用挂在 loop 上
- 每来一个 `HTTP/WebSocket` 连接，就创建若干个任务在 loop 里运行（都是 async 函数）

#### ✅ 1. 什么是 async def（协程函数）

普通函数：
```py
def foo():
    return 1

x = foo()   # x = 1
```

协程函数：
```py
async def foo():
    return 1

x = foo()   # x 是一个 “协程对象”，函数并不会立即执行
print(x)
```

输出类似：
```
<coroutine object foo at 0x...>
```

也就是说：

async def 声明一个协程函数，调用它不会执行，而是返回一个协程对象，必须 await 才能真正运行。

#### ✅ 2. await 的意义：等待一个协程执行完成

你必须在 async 函数里 await：
```py
import asyncio

async def foo():
    return 1

async def main():
    result = await foo()   # 等待 foo 执行完
    print(result)

asyncio.run(main())
```

输出：
```
1
```

关键点：

await foo() 会把控制权交还给事件循环

当 foo 执行完毕后，结果回到 main

#### ✅ 3. asyncio.run()：脚本入口，用来启动事件循环

你不能在普通函数里直接写：
```py
await foo()   # ❌ SyntaxError
```

要让协程跑起来，必须：
```py
asyncio.run(main())
```

所以 `async/await` 程序通常的结构是：
```py
import asyncio

async def main():
    ...

if __name__ == "__main__":
    asyncio.run(main())
```

#### ✅ 4. 模拟并发：asyncio 如何让多个任务“同时”运行？

示例：两个任务，每个睡 1 秒，但总时间不是 2 秒，而是 1 秒！
```py
import asyncio

async def task(name):
    print(f"{name} start")
    await asyncio.sleep(1)
    print(f"{name} end")

async def main():
    await asyncio.gather(
        task("A"),
        task("B")
    )

asyncio.run(main())
```

输出：
```
A start
B start
A end
B end
```

耗时 ≈ 1 秒，而不是 2 秒。

因为：

await asyncio.sleep(1) 会让出控制权，让事件循环去执行别的任务。

#### ✅ 5. async with：异步上下文管理器

普通 with：
```py
with open("a.txt") as f:
    data = f.read()
```

异步情况下：

- WebSocket 连接
- aiofiles 文件 I/O
- 数据库连接（asyncpg 等）
- MCP 的 websocket_client()

都使用 async with

例子：
```py
class AsyncResource:
    async def __aenter__(self):
        print("enter async resource")
        return "resource"

    async def __aexit__(self, exc_type, exc, tb):
        print("exit async resource")

async def main():
    async with AsyncResource() as r:
        print("using", r)

asyncio.run(main())
```

输出：
```
enter async resource
using resource
exit async resource
```

意义：

- async with 在进入/退出时都是异步执行
- 用于需要异步清理的场景（关闭连接、释放资源）

#### ✅ 6. 综合示例：模拟 async 网络请求

这里用 sleep 模拟“异步 I/O 请求”：
```py
import asyncio

async def fake_request(url):
    print(f"requesting {url}")
    await asyncio.sleep(1)
    return f"{url} result"

async def main():
    async with asyncio.TaskGroup() as tg:
        task1 = tg.create_task(fake_request("https://a.com"))
        task2 = tg.create_task(fake_request("https://b.com"))

    print(task1.result())
    print(task2.result())

asyncio.run(main())
```

输出：
```
requesting https://a.com
requesting https://b.com
https://a.com result
https://b.com result
```

#### ✅ 7. async/await VS 普通同步阻塞的区别

同步阻塞：
```py
import time

def task(name):
    print(name, "start")
    time.sleep(1)
    print(name, "end")

task("A")
task("B")
```

耗时 ≈ 2 秒

异步：
```py
import asyncio

async def task(name):
    print(name, "start")
    await asyncio.sleep(1)
    print(name, "end")

async def main():
    await asyncio.gather(task("A"), task("B"))

asyncio.run(main())
```

耗时 ≈ 1 秒

差别在于：

- time.sleep() —— 阻塞整个线程
- await asyncio.sleep() —— 只挂起当前协程，让 event loop 去执行其他任务

#### ✅ 8. 为什么有些函数必须 async？有些不用？
##### 必须 async 的：

- 里面用 await
- 需要用 async with
- 是 ASGI（FastAPI/Starlette）接口，如：
    ```py
    async def app(scope, receive, send):
    ```
- 是 MCP 的异步方法，如：
    ```py
    async def get_oai_tools_from_mcp(...)
    ```
##### 可以是普通 def 的：

- 内部没有 await
- 调用的是同步 API，如：
    ```py
    response = llm_client.chat.completions.create(...)
    ```

你的代码中：
- MCP 会话相关方法都用 async
- LLM 请求是同步 → 所以函数是普通 def