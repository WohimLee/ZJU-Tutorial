## 例子
金融系统非常依赖 `高并发 I/O、实时行情、交易撮合、风控检查`，这些都是协程特别擅长的领域。

#### ✅ 金融场景例子 1：实时行情订阅（Market Data Feed Handler）
##### 📌 场景描述

交易系统从交易所或行情供应商（如 CME、NASDAQ、Binance、Bloomberg）接收实时行情数据：

- 数千个股票/期货/Tick 流数据
- 每秒几万次数据更新
- 每个数据包需要快速解析、传递给下游策略

##### 为什么用协程？

###### 因为接收行情属于 大量并发 I/O：

- 网络 socket 大量并发 read
- 并行接收多个 symbol 的订阅
- 每个订阅都是独立的数据流

###### 使用线程意味着：

- 为每个 symbol 开一个线程 → 上千线程，极不现实
- 线程切换开销巨大

###### 使用协程则是：
- 每个行情订阅使用一个协程
- `asyncio、Go、Rust` 都可以轻松处理成千上万条 `stream`

简化代码示例（Python asyncio）
```py
async def handle_feed(symbol, reader):
    while True:
        data = await reader.read(1024)   # 网络 I/O
        price = parse_tick(data)
        update_cache(symbol, price)
        notify_strategies(symbol, price)

async def main():
    tasks = []
    for symbol in symbols:
        r = await connect_feed(symbol)
        tasks.append(asyncio.create_task(handle_feed(symbol, r)))
    await asyncio.gather(*tasks)
```

意义：

- 实时处理多达数千个行情流
- 没有线程开销
- 单线程即可高效处理 I/O

#### ✅ 金融场景例子 2：高频交易（HFT）中的网关 I/O

HFT（High Frequency Trading）系统中：

- 接收行情、发送订单、监听订单回报都使用 socket
- 极端要求低延迟
- 但仍需要同时处理大量连接

协程适用于：

- 非阻塞网络 IO
- 低延迟任务调度

Go 的 goroutine 在 HFT 中广泛用于：

- order gateway（订单网关）
- FIX/FAST 协议处理
- 多路行情处理

Python asyncio 在纯 HFT 中较少，但在上层策略系统中常用。

#### ✅ 金融场景例子 3：风控系统（Risk Engine）中大量外部依赖查询

风控系统在判断是否允许下单时需要：

- 查 Redis 获取账户余额
- 查数据库获取风险参数
- 查缓存服务器
- 调用外部风控微服务

这些都是大量 I/O bound 的任务。

协程可以并发执行这些 I/O 查询：
```py
async def check_risk(order):
    balance = await redis.get(order.user)
    pos = await db.fetch_positions(order.user)
    limits = await limits_api.get(order.symbol)

    return validate(balance, pos, limits)
```

相比开 1000 个线程访问数据库，协程更轻量：

- 单线程可轻松处理几万并发
- 减少锁争用
- 风控响应更快

#### ✅ 金融场景例子 4：量化策略系统中订阅大量数据源

例如 CTA/Crypto/股票量化系统会同时订阅：

- 实时行情
- 订单簿深度（order book）
- 成交明细（trades）
- 多家交易所 Websocket

使用协程可同时处理多家交易所的 Websocket：
```py
async def subscribe_okx():
    async with websockets.connect(url) as ws:
        await ws.send(sub_msg)
        async for msg in ws:
            handle_okx(msg)

async def subscribe_binance():
    async with websockets.connect(url) as ws:
        # 同上

await asyncio.gather(subscribe_okx(), subscribe_binance())
```

协程特别适合 WebSocket 这类“持续连接 + 实时数据 + 高并发 I/O”。

#### ✅ 金融场景例子 5：撮合引擎外部的 I/O 层（并非撮合本身）

撮合引擎（matching engine）一般会使用 C++ 或硬件（FPGA），不会直接使用协程。

但撮合外部层：

- 订单接入（gateway）
- 会话管理（FIX/REST/Websocket）
- 订单回报推送（drop copy）
- 分布式日志写入（Kafka）

这些同样是：多连接 + 高并发网络 I/O → 协程非常适合。

#### 📌 为什么金融系统特别偏爱协程（尤其是 Go/Rust 的 async）？
##### ✔ 大量并发 + 少量 CPU 任务

金融系统中：

- I/O bound 远远多于 CPU bound（行情、订单、风控大多是 I/O）
- 协程几乎完美匹配这种场景

##### ✔ 成千上万个连接

Websocket、TCP、FIX，都需要长期保持连接。

线程无法做到：
- 1 万个线程？
- 线程切换开销巨大

协程可以做到：
- 1 万个协程是常规水平
- 内存占用极低（几十 KB）
- 事件循环调度高效