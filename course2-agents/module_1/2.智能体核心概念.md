## Agent 核心概念

可以把“只有大模型”的系统想象成一个很会聊天的专家客服；而接上 Agent 后，它变成了一个能直接帮你办事的执行助手。比如你说“帮我把这份报销单录进系统”，它不只是告诉你怎么填，而是自己去查数据、打开系统、完成录入。

智能体（AI Agent）重要的“基础设施”：`MCP（Model Context Protocol）`、`Function Calling` 和 `A2A（Agent to Agent protocol）`。它们对应的是三种不同的协作关系：

- `MCP`：定义 `AI Agent` 与各种 `AI Tools` 之间如何“发现工具、注册工具以及调用工具”的协议。注意，MCP 本身并不直接跟 LLM 对话
- `Function Calling`：定义 `AI Agent` 和 `LLM` 之间，如何通过“函数调用”的形式交换结构化信息的协议。
- `A2A`：定义 `AI Agent` 与 `AI Agent` 之间如何“彼此发现、协同工作和分配任务”的协议。


### 1 AI Agent
AI Agent（人工智能体）：它是一种能自己“看情况”、自己“想办法”、自己“动手做事”的智能系统，用来完成具体任务。

可以这样理解 LLM 和 Agent 的关系：
- LLM 更像一个知识特别丰富的“军师”，擅长分析和给建议。
- Agent 则像一支“行动小队”，会根据军师的建议，去查数据、调接口、做操作，把事情真正落地

- 如果只有 LLM，没有 Agent：它能回答问题、写文案、出主意，但很少真正去连接系统、推动流程，更多停留在“说得好”。
- 如果只有 Agent，没有 LLM：它就变成一套死板的自动化脚本，只能按预先写好的流程走，一旦场景稍微复杂、需求有变化，就容易“懵住”。

AI Agent 和传统的 SOP / 工作流核心差别:
- 传统流程：基于固定规则，“如果发生 A，就做 B”，路径基本写死
- AI Agent：基于目标，会自己规划步骤、在执行中调整策略；它能感知环境变化，处理模糊、描述不清甚至中途变化的任务，靠的是大模型在语言理解、推理和泛化方面的能力

一个真正完整的 Agent，除了背后那颗“聪明的大模型”，还少不了几块关键能力:
- **感知模块**：像“信息雷达”，通过 `API、搜索、文件系统` 等渠道，把外部情况收集进来
- **工具模块**：像“一整箱工具”，能调用 `函数、API、软件服务` 等，对系统和现实世界产生实际影响——Function Calling、MCP 等技术就用在这里
- **记忆模块**：像“项目记录和经验库”，用向量数据库或记忆流记录过去发生过什么，方便之后做长期规划和复用经验

### 2 MCP

MCP 整个通信过程分为3个阶段：

1. 初始化阶段：也就是 `MCP Client` 和 `MCP Server` 的握手过程。通常，`MCP Client` 是以内置组件的形式存在于 `Agent` 内部
2. 工具注册阶段：`MCP Client` 会询问 `MCP Server`，你有哪些可用的 `tools（工具）、resources（资源）、templates（模板）`。`MCP Server` 会按照规定的格式返回对应的能力描述。
3. 工具调用阶段：当大模型需要调用工具时，会告诉 `Agent`，你需要用 `{"city":"杭州"}` 这个参数，去调用下 `get_forecast` 这个工具。`MCP Client` 知道这个工具是“获取天气信息”这个 `MCP Server` 提供的，调用即可

### 3 Function Calling


### 4 Context Engieering
Agent的本质就是一个精心设计的Prompt。因为大模型本质上是“上下文学习者”：它们没有长期的记忆，每次交互都是独立的。你提供的上下文就是它此次交互的全部世界。

因此，要想实现完整的Agent功能，在传递给LLM的信息中，除了System prompt，user message之外，还要包括Docs（领域知识，工作对象等），工作记忆（Message history）等。把这些内容都汇总起来就是LLM需要的Context（上下文），而这个汇总（精炼、压缩）的工作就叫Context Engineering (https://www.anthropic.com/engineering/effective-context-engineering-for-ai-agents)。
这也是Context Engineering和Prompt Engineering的主要区别。

### 5 A2A

A2A是google开源的开放协议。包含如下核心概念：

概念|描述 
:-|:-
Agent Card（卡片） | 位于 /.well-known/agent.json，描述能力、技能、端点 URL 和认证要求，用于发现
A2A Server（服务器） |实现协议方法，管理任务执行
A2A Client（客户端）|发送请求如 tasks/send 或 tasks/sendSubscribe，消费 A2A 服务
Task(任务)|核心工作单位，有唯一 ID，状态包括 submitted、working 等
Message(消息)|通信单位，角色为 user 或 agent，包含 Parts
Parts(部分)|内容单位，包括 TextPart、FilePart、DataPart
Artifacts(工件)|任务输出，包含 Parts
流式传输|使用 SSE 事件更新长期任务状态
推送通知|通过 webhook 发送更新

和 `MCP` 一样，`A2A` 采用的也是 `JSON-RPC` 协议，其工作机制也很类似，主要包括Agent 的发现、注册和使用，通信大致流程如下：
1. 发现：客户端从 /.well-known/agent.json 获取 Agent Card，了解智能体的能力。
2. 启动：客户端发送任务请求
3. 处理：服务器处理任务，可能涉及流式更新或直接返回结果
4. 交互（可选）：若任务状态为 input-required，客户端可发送更多消息，使用相同 Task ID 提供输入
5. 完成：任务达到终端状态（如 completed、failed 或 canceled）